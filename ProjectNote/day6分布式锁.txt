CAP 

Cache Aside Pattern


1  缓存击穿  
    问题1 当数据没有缓存的时候，正好有很多个请求一起去访问数据
    解决办法 1 ：
	    利用setnx 增加分布式锁  
		      同时只有一个线程可以访问数据库，其他线程等待
			  
	问题2：当某个线程占用锁时间过长 ，完全没有释放锁的能力的时候  如何处理
	     设定过期时间  set key value  nx  ex 10
	
	 问题3  当获得锁的线程A 处理超时 锁被释放  ，线程B得到锁  ， 线程A在线程B处理的时候 ，完成了自己的工作要释放锁，会错误的把线程B的锁释放掉，造成线程C又得到了锁。
	   解决：  得到锁的线程值会释放自己的锁   随机生成一个token 保存在线程中的变量 ，释放锁的时候进行判断，只释放value值是token锁
	   
	 问题4  通过lockkey中的value进行判断 ，判断通过后 在要执行删除前，突然锁被换掉了 ， 实际删除还是删除别的。
             判断语句 和 删除语句的 非原子化造成的 
        解决：  事务可以把命令打包成原子，但是会取消掉晚提交的事务  	   用lua脚本  事务的串行 执行（推荐）	 
	   
	   
  2  穿透  
       查询一个不存在与缓存和数据库的数据  
	       永远不会加载缓存，会反复查询数据库 ，造成io压力
		   
	解决方案：  把一个空值放到缓存中，表示数据暂时没值  
		   
		   
		   
		   redisson 的 lock 比 手工实现的redis分布式锁有哪些方便的地方 
		   
		   1、 不会释放别人的锁 
		   2、 redis的锁    锁的特性： 1 互斥  2 阻塞
		   3、 可重入 
		   
		   
	尝试利用redisson 加锁 实现业务阻塞 	 
      
     	问题1  lock解决  
		问题2   lock 上有参数可以设置锁的过期时间
		问题3  问题4  不会释放别人的锁
		
		不用手工进行自旋等待操作 而且 还可以设定等待的超时时间 
		
		
		
		
    写操作 ？ 怎么办  
 ap 方案  关注可用性
	当数据发生主动变化的时候  如何处理缓存 ？
	   缓存是 清理 还是 更新 ？
	   
	   删除缓存 失效缓存  
	      弊端 ： 增加一次的miss 
		  
	   更新缓存 
	      弊端 ： 并发修改时 由于乱序问题 可能造成数据库与缓存不一致  
		  
    先更新数据库 还是先删缓存 
        有主从结构的数据库 不要先删缓存  
		因为 当数据库没有同步到从机的时候 从机被读取 会把旧数据更新到缓存中 造成数据库是新数据而缓存是旧数据
    
        后删缓存 有可能  数据更新成功 缓存更新失败  造成数据库与缓存不一致 
		
		保险 前后都删一次缓存 
		
		
方法二  在做更新数据库之前 加锁  直到数据库更新完 ，不允许其他线程对数据库和缓存进行任何的读和写操作   降低可用性
cp 方案  关注一致性 
    
		


	

	
		  
		  
	   
	   
	   
	   
	   
	
	
	
	
	



	
		   
		   
    
   